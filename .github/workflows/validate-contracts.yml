name: Validate Data Contracts

on:
  repository_dispatch:
    types: [validate-contract]

jobs:
  validate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
      - name: Parse repository info
        id: repo-info
        run: |
          REPO="${{ github.event.client_payload.repo }}"
          OWNER=$(echo $REPO | cut -d'/' -f1)
          REPO_NAME=$(echo $REPO | cut -d'/' -f2)
          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT

      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ steps.repo-info.outputs.owner }}
          repositories: ${{ steps.repo-info.outputs.repo_name }}

      - name: Checkout platform repo (contracts)
        uses: actions/checkout@v4

      - name: Checkout producer repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.repo }}
          ref: ${{ github.event.client_payload.pr_ref }}
          path: producer-repo
          token: ${{ steps.generate-token.outputs.token }}

      - name: Post initial PR comment
        id: initial-comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const repo = '${{ github.event.client_payload.repo }}';
            const [owner, repoName] = repo.split('/');
            const prNumber = ${{ github.event.client_payload.pr_number }};

            const comments = await github.rest.issues.listComments({
              owner,
              repo: repoName,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.body.includes('Contract Validation')
            );

            const body = [
              '## üîç Contract Validation In Progress',
              '',
              'Checking if this PR breaks data contracts...',
              '',
              '**Status:** ‚è≥ Validating...',
              '',
              '**Contracts being checked:**',
              '- `orders`',
              '',
              '---',
              'ü§ñ Powered by Claude Code | [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})'
            ].join('\n');

            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo: repoName,
                comment_id: botComment.id,
                body: body,
              });
              return botComment.id;
            } else {
              const newComment = await github.rest.issues.createComment({
                owner,
                repo: repoName,
                issue_number: prNumber,
                body: body,
              });
              return newComment.data.id;
            }

      - name: Validate contracts with Claude
        id: validate
        uses: anthropics/claude-code-action@v1
        env:
          ANTHROPIC_BASE_URL: ${{ secrets.ANTHROPIC_BASE_URL }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_AUTH_TOKEN }}
          github_token: ${{ steps.generate-token.outputs.token }}
          prompt: |
            You are a data contract validation expert. Analyze the producer code against data contracts.

            **CRITICAL: Output ONLY the formatted results. NO explanations, NO "I will analyze", NO process descriptions.**

            **Required Output Format:**

            ## üîç Contract Validation Results

            **Status**: [‚úÖ PASS | ‚ö†Ô∏è WARNING | üö® BREAKING]

            [If PASS: "No breaking changes detected."]
            [If issues: List top 3 critical issues]

            ### Critical Issues

            #### üî¥ Enum Drift
            - **Field**: `order_status`
            - **Problem**: Using "REFUNDED" which is not in contract's allowed enum values
            - **Location**: OrderProducer.java:11, :38
            - **Fix**: Remove REFUNDED from enum or update contract first

            #### üü† Hardcoded Status
            - **Field**: `order_status`
            - **Problem**: All orders hardcoded to REFUNDED instead of using actual order status
            - **Location**: OrderProducer.java:38
            - **Fix**: Change to `.orderStatus(order.getStatus().name())`

            ---
            **Contracts checked**: orders

            **Analysis Instructions:**
            1. Read `contract-mappings.yaml` for `${{ github.event.client_payload.repo }}`
            2. Read contract YAMLs from `contracts/` directory
            3. Analyze code in `producer-repo/` (PR #${{ github.event.client_payload.pr_number }})
            4. For each required field in the contract, verify the producer code will emit the EXACT field name in JSON:
               - Java: Field name `orderTotal` ‚Üí JSON field `"orderTotal"` (camelCase)
               - Java: Field name `amount` ‚Üí JSON field `"amount"` (NOT `"order_total"`)
               - Contract field names use snake_case: `order_total`, `order_id`, etc.
               - If Java field doesn't match contract field (accounting for camelCase ‚Üî snake_case), it's BREAKING
            5. Check for:
               - **P0 (BREAKING)**: Enum drift, field removal/rename, type changes, unit mismatches, business rule violations
               - **P1 (WARNING)**: Default/null changes that don't break existing consumers
               - **P2 (WARNING)**: PII leakage
            6. Output ONLY the formatted result (no preamble, no "I will...", no process explanations)

            **Field Name Validation (CRITICAL):**
            - Contract uses snake_case: `order_total`, `order_status`, `customer_id`
            - Java typically uses camelCase: `orderTotal`, `orderStatus`, `customerId`
            - Verify Java field names match contract (with case conversion)
            - Example BREAKING: Java field `amount` does NOT match contract field `order_total`
            - Example OK: Java field `orderTotal` matches contract field `order_total` (camelCase ‚Üî snake_case)

            **Status Rules (CRITICAL):**
            - Use üö® BREAKING if ANY P0 issues found (enum drift, field removal/rename, type changes, unit mismatches, business rule violations)
            - Use ‚ö†Ô∏è WARNING if only P1/P2 issues found
            - Use ‚úÖ PASS only if NO issues found
            - DO NOT mark as PASS if you list any issues in "Critical Issues" section

            **Output Rules:**
            - Start immediately with "## üîç Contract Validation Results"
            - Max 3 issues
            - Each issue: 4 bullets (Field, Problem, Location, Fix)
            - Keep total under 25 lines
            - NO conversational text

            Begin analysis.

      - name: Debug - List files after Claude validation
        if: always()
        run: |
          echo "=== Current directory ==="
          pwd
          echo ""
          echo "=== Files in current directory ==="
          ls -la
          echo ""
          echo "=== Looking for validation-results.md ==="
          find . -name "validation-results.md" -type f 2>/dev/null || echo "Not found"
          echo ""
          echo "=== Execution file from Claude Code Action ==="
          echo "Execution file: ${{ steps.validate.outputs.execution_file }}"
          if [ -f "${{ steps.validate.outputs.execution_file }}" ]; then
            echo "File exists, size: $(wc -c < "${{ steps.validate.outputs.execution_file }}") bytes"
          else
            echo "Execution file not found"
          fi

      - name: Update PR comment with results
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const fs = require('fs');
            const repo = '${{ github.event.client_payload.repo }}';
            const [owner, repoName] = repo.split('/');
            const prNumber = ${{ github.event.client_payload.pr_number }};

            // Get comment ID from previous step or find it manually
            const commentIdFromStep = '${{ steps.initial-comment.outputs.result }}';
            let commentId = null;

            if (commentIdFromStep && commentIdFromStep !== '') {
              commentId = parseInt(commentIdFromStep);
            } else {
              // Find existing comment if initial step failed
              const comments = await github.rest.issues.listComments({
                owner,
                repo: repoName,
                issue_number: prNumber,
              });
              const botComment = comments.data.find(c =>
                c.body.includes('Contract Validation')
              );
              if (botComment) {
                commentId = botComment.id;
              }
            }

            // Try multiple methods to get validation results
            let validationResults;

            // Method 1: Read validation-results.md (what we told Claude to write)
            if (fs.existsSync('validation-results.md')) {
              try {
                validationResults = fs.readFileSync('validation-results.md', 'utf8');
                console.log('Successfully read validation-results.md');
              } catch (error) {
                console.log('Error reading validation-results.md:', error.message);
              }
            }

            // Method 2: Read from execution file if validation-results.md doesn't exist
            if (!validationResults) {
              const executionFile = '${{ steps.validate.outputs.execution_file }}';
              if (executionFile && fs.existsSync(executionFile)) {
                try {
                  // The execution file is a JSON array of turn objects (not {turns: [...]})
                  const turns = JSON.parse(fs.readFileSync(executionFile, 'utf8'));
                  let claudeOutput = '';

                  if (Array.isArray(turns)) {
                    for (const turn of turns) {
                      // Look for assistant messages with text content
                      if (turn.type === 'assistant' && turn.message && turn.message.content) {
                        for (const content of turn.message.content) {
                          if (content.type === 'text' && content.text) {
                            claudeOutput += content.text + '\n\n';
                          }
                        }
                      }
                    }
                  }

                  if (claudeOutput.trim()) {
                    // Extract only the formatted section (from "## üîç" onwards)
                    const match = claudeOutput.match(/## üîç Contract Validation Results[\s\S]*/);
                    if (match) {
                      validationResults = match[0].trim();
                      console.log('Successfully extracted formatted results from execution file');
                    } else {
                      // Fallback: use all output if no formatted section found
                      validationResults = claudeOutput.trim();
                      console.log('Using full output (no formatted section marker found)');
                    }
                  } else {
                    console.log('No text content found in execution file');
                  }
                } catch (error) {
                  console.log('Error reading execution file:', error.message);
                }
              }
            }

            // Method 3: Fallback message with link
            if (!validationResults || validationResults.trim() === '') {
              validationResults = [
                '## ‚ö†Ô∏è Could Not Extract Validation Results',
                '',
                'The validation completed, but results could not be extracted automatically.',
                '',
                '**Please check the [workflow summary](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed validation results.**',
                '',
                'This is a known issue we are working to resolve.'
              ].join('\n');
            }

            const footer = [
              '',
              '---',
              'ü§ñ Powered by Claude Code | [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})'
            ].join('\n');

            const fullComment = validationResults + footer;

            if (commentId) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner,
                repo: repoName,
                comment_id: commentId,
                body: fullComment,
              });
            } else {
              // Create new comment if we couldn't find existing one
              await github.rest.issues.createComment({
                owner,
                repo: repoName,
                issue_number: prNumber,
                body: fullComment,
              });
            }
